---
layout: post
category: java  
title: java虚拟机类加载机制
tags: java虚拟机
---

##### 代码编译的过程：本地机器码变为字节码的过程
##### java动态拓展依赖于java运行时动态加载和动态连接的能力
1. 类加载的顺序：加载->验证->准备->解析->初始化->使用->卸载
2. 加载过程：读取类的二进制流数据，将类代表的静态存储结构转化为方法区的运行时数据结构，然后生成java.lang.class对象
3. 验证过程：目的就是确保二进制流数据符合虚拟机的要求并且不会危害虚拟机，但是验证不是必须的步骤，可以进行设置不进行这个过程
4. 准备过程：为类变量分配内存并设置初始值，将类变量在方法区进行分配，初始值一般为数据类型的零值，真正的赋值一般是在初始化阶段，但是常量类变量是在该阶段进行的
5. 解析过程：虚拟机将符号引用替换为直接引用的过程，直接引用的变量必须已经加载到内存中，符号引用则只需要能定位到目标即可
6. 初始化过程：执行类构造器<clinit>()方法的过程，包括类变量和static块中的内容
7. 使用过程与卸载过程，略掉


#### java中类如何才是唯一的？
任意一个类，它的唯一性由加载它的类加载器和类本身一起确定，不同的类加载器加载同一个类，那么虚拟机中就会存在这个类的不同的类对象，因为每一个类加载器，都拥有一个独立的类名称空间

#### 类加载器的分类
1. 启动类加载器：负责加载<java_home>\lib目录中的类库，或者是被-Xbootclasspath参数所指定的路径中，并且被java虚拟机所识别(必须，有些随便写的类放在该目录也不会被加载)的类库
2. 拓展类加载器：负责加载<java_home>\lib\ext目录中,或者被java.ext.dirs所指定的路径下的类库
3. 应用程序类加载器：负责加载用户类路径上的类库

#### 双亲委派模型
当类加载器收到加载类的请求后，它会委托它的父类去处理这个请求，直到启动类加载器，如果父类无法加载该类，那么父类会告诉子类无法加载，子类则会尝试自己去加载，一层层直到最初的类加载器。

#### 3次破坏双亲委派模型的情况
1. 为了向前兼容，jdk1.2之前，用户去继承java.lang.ClassLoader的目的就是重写loadClass方法，但是1.2的时候，双亲委派模型引入后，其实现就在loadClass中，所以重写就破坏了模型，在loadClass方法中有一个findClass方法，如果父类加载失败，则会使用findClass来加载，所以1.2之前对loadClass方法重写实际上算是一种破坏模型的情况
2. JNDI(对资源进行集中管理与查找)服务等，由于JNDI要查找服务提供者，加载类库，但是它的代码是由启动类加载器去进行加载的，它需要调用部署在用户类路径上的JNDI接口提供者，但启动类加载器是加载不了用户类路径上的代码的，所以，设计团队引入了线程上下文类加载器，然后，JNDI服务使用这个线程上下文加载器去加载SPI(Service Provider Interface)服务类文件
3. OSGI实现模块化热部署，此情况下，类加载器不再是双亲委派模型，而是更加复杂的网状结构，此不再赘述